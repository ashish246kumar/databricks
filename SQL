__________________________________________________________________
For each day display the total amount of admissions on that day. Display the amount changed from the previous date.

WITH cte AS (
SELECT admission_date, COUNT(*) AS total_admissions
FROM admissions
GROUP BY admission_date
)
SELECT admission_date, total_admissions
total_admissions LAG(total_admissions, 1) OVER(ORDER BY admission_date)
FROM cte
____________________________
Show the percent of patients that have 'M' as their gender. Round the answer to the nearest hundreth number and in percent form.

SELECT SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) 1.0/COUNT(*) AS mal
FROM patients

__________________________________________________________________________________________________________
We are looking for a specific patient. Pull all columns for the patient who matches the following criteria:
- First_name contains an 'r' after the first two letters.
- Identifies their gender as 'F'
-Born in February, May, or December
Their weight would be between 60kg and 80kg
Their patient_id is an odd number
- They are from the city 'Kingston'

SELECT
FROM patients
WHERE first_name LIKE r%
AND gender = 'F'
AND MONTH(birth_date) IN (2,5,12)
AND weight BETWEEN 60 AND 80
AND patient_id%2 = 11
AND city 'Kingston'
_______________________________________________________________________________________________________________________
Show the provinces that has more patients identified as 'M' than 'F'.
Must only show full province_name

 WITE cte AS
(
 SELECT
pn.province_name, COUNT(*) AS no_of_patients
,SUM(CASE WHEN gender 'F' THEN 1 ELSE 0 END) AS female_count
, SUM(CASE WHEN gender 'M' THEN 1 ELSE 0 END) AS male_count
FROM patients p
 INNER JOIN province_names pn ON p.province_id=pn.province_id
 GROUP BY pn.province_name
)
select province_name from cte where male_count > female_count

________________________________________________
Each admission costs $50 for patients without insurance, and $10 for patients with insurance. All patients with an even patient_id have insurance.
Give each patient a 'Yes' if they have insurance, and a 'No' if they don't have insurance. Add up the admission_total cost for each has_insurance group.

 SELECT CASE WHEN p.patient_id%2=0 THEN 'Yes' ELSE 'No' END AS has_insura
SUM(CASE WHEN p.patient_id%2=0 THEN 10 ELSE 50 END) AS cost 2
 FROM patients p
 INNER JOIN admissions a ON p.patient_id=a.patient_id
 GROUP BY CASE WHEN p.patient_id%2=0 THEN 'Yes' ELSE 'No' END

___________________
All patients who have gone through admissions, can see their medical documents on our site. Those patients are given a temporary password after their first admission. Show the patient_id and temp_password.
The password must be the following, in order:
1. patient_id
2. the numerical length of patient's last_name
3. year of patient's birth_date

SELECT p.patient_id
CONCAT(p.patient_id, LEN(p.last_name), YEAR(p.birth_date)) AS temp_pa
FROM patients p
WHERE patient_id IN (SELECT patient_id FROM admissions)

________________________________________________________
Show all of the patients grouped into weight groups.
Show the total amount of patients in each weight group.
Order the list by the weight group decending.
For example, if they weight 100 to 109 they are placed in the 100 weight group, 110-119 = 110 weight group, etc.

SELECT COUNT(*) no_of_patients, FLOOR (weight/10)*10 AS weight_group
FROM patients
GROUP BY FLOOR (weight/10)*10
ORDER BY weight_group DESC
________________
Display a single row with max_visits, min_visits, average_visits where the maximum, minimum and average number of admissions per day is calculated. Average is rounded to 2 decimal places.
WITH cte AS (
SELECT admission_date, COUNT(*) AS no_of_visits
FROM admissions
GROUP BY admission_date
)
SELECT MAX(no_of_visits) AS max_vigits, MIN(no_of_visits) AS min_visits
ROUND (AVG(no_of_visits), 2) AS avg_visits
FROM cte
innon join admissions on nationt idea patient id

_________
Show patient_id, first_name, last_name from patients whose does not have any records in the admissions table. (Their patient_id does not exist in any admissions.patient_id rows.)
Table
patient and admssion

SELECT patient_id, first_name, last_name
FROM patients I
WHERE patient_id NOT IN (SELECT patient_id FROM admissions)

or 
SELECT 
    p.patient_id,
    p.first_name,
    p.last_name
FROM patients p
WHERE NOT EXISTS (
    SELECT 1
    FROM admissions a
    WHERE a.patient_id = p.patient_id
);

or
SELECT p.patient_id, first_name, last_name, a.patient_id
FROM patients p
LEFT JOIN admissions a ON p.patient_id=a.patient_id
WHERE a.patient_id IS null
_________________________________________________
Display patient's full name, height in the units feet rounded to 1 decimal, weight in the unit pounds rounded to O decimals,
birth_date,
gender non abbreviated.
Convert CM to feet by dividing by 30.48.
Convert KG to pounds by multiplying by 2.205.

SELECT first_name || || last_name AS full_name
Ÿà ROUND(height/30.48,1) AS height_feet
* ROUND (weight 2.205,0) AS weight_pound
birth_date
CASE WHEN gender = 'M' THEN 'MALE' ELSE 'FEMALE
END AS gender_type
FROM patients p
I

______________________________________
Show the total amount of male patients and the total amount of female patients in the patients table. Display the two results in the same row.

SELECT
    SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_count,
    SUM(CASE WHEN gender = 'F' THEN 1 ELSE 0 END) AS female_count
FROM patients;


Show patient_id, diagnosis from admissions. Find patients admitted multiple times for the same diagnosis.


- SELECT p.patient_id, a.diagnosis
FROM patients p
INNER JOIN admissions a ON p.patient_id = a.patient_id
GROUP BY p.patient_id, a.diagnosis
HAVING COUNT(*)>1

Show the city and the total number of patients in the city.
Order from most to least patients and then by city name ascending.

SELECT city, COUNT(*) AS no_of_patients
FROM patients
GROUP BY city
ORDER BY no_of_patients DESC, city





Show first name, last name and role of every person that is either patient or doctor.
The roles are either "Patient" or
"Doctor"

1 SELECT first_name, last_name 'Patient' AS role
2 FROM patients
3 UNION ALL
4 SELECT first_name, last_name, 'Doctor' AS role
5 FROM doctors


Show all allergies ordered by popularity. Remove NULL values from query.

SELECT allergies, COUNT(*) AS popularity
FROM patients
WHERE allergies IS NOT NULL
GROUP BY allergies
ORDER BY popularity DESC

We want to display each patient's full name in a single column. Their last_name in all upper letters must appear first, then first_name in all lower case letters. Separate the last_name and first_name with a comma. 
Order the list by the first_name in decending order EX: SMITH,jane

SELECT CONCAT(UPPER(last_name),',', LOWER (first_name))
FROM patients
ORDER BY first_name DESC

Show all of the days of the month (1-31) and how many admission_dates occurred on that day. Sort by the day with most admissions to least admissions.

1 SELECT DAY(admission_date), COUNT(*) AS total_admits
2 FROM admissions
3 GROUP BY DAY(admission_date)
4 ORDER BY total_admits DESC
_____________________________

Show patient_id,
attending_doctor_id, and diagnosis for admissions that match one of the two criteria:
1. patient_id is an odd number and attending_doctor_id is either 1, 5, or 19.
2. attending_doctor_id contains a 2 and the length of patient_id is 3 characters.


- SELECT patient_id, attending_doctor_id, diagnosis
FROM admissions
- WHERE (patient_id%2= 1 AND attending_doctor_id IN (1,5,19))
KOR
- (LEN(patient_id)=3 AND at Tending_doctor_id LIKE '%2%')


Show first_name, last_name, and the total number of admissions attended for each doctor.
Every admission has been attended by a doctor.

table admission,doctor

SELECT d.first_name, d.last_name, COUNT(*) AS no_of_admissions
FROM admissions a
INNER JOIN doctors d ON a.attending_doctor_id= d.doctor_id
- GROUP BY d.first_name, d.last_name
I

For each doctor, display their id, full name, and the first and last admission date they attended.
Admission, doctor

1 SELECT d.doctor_id, CONCAT(d.first_name,, d.last_name) AS full_name
2, MIN(a.admission_date) AS frist_date, MAX(a.admission_date) AS last_date
3 FROM admissions a
4 INNER JOIN doctors d ON a.attending_doctor_id = d.doctor_id

6 GROUP BY d.doctor_id, CONCAT(d.first_name,'', d.last_name)


_____________________________

Display the total amount of patients for each province. Order by descending.
table patients,province

SELECT pn.province_name, COUNT(*) AS total_p
2 FROM patients p
3 INNER JOIN province_names pn ON p.province_id=pn.province_id
4 GROUP BY pn.province_name
5
province names TABLE

_____________________________

For every admission, display the patient's full name, their admission diagnosis, and their doctor's full name who diagnosed their problem.
table patients,admissions,doctors

2
SELECT p.first_name || ' ' || p.last_name AS patient_name
a.diagnosis, d.first_name || || d.last_name AS doctor_name
3
FROM patients p
4
INNER JOIN admissions a ON p.patient_id=a.patient_id
5
INNER JOIN doctors d ON a.attending_doctor_id=d.doctor_id
7
_____________________________

ORIG_CDE_VEH_USE_TYPE


__________________________
Given a FriendRequest table where requester_id and accepter_id represent a friend request being sent and accepted, write an SQL query to find the user(s) who have the most friends. A user can be a 'friend' by either sending or accepting a request.

Input Format:
A table named FriendRequest with the following schema:

FriendRequest

Column Name	Type
requester_id	INTEGER
accepter_id	INTEGER
request_date	DATE
accept_date	DATE
requester_id and accepter_id are foreign keys to a Users table (not provided, assume their existence).

Output Format:
Return the id of the user(s) with the most friends and their num_friends count. If multiple users have the same maximum number of friends, return all of them.

Example 1:
Input:
FriendRequest
| requester_id | accepter_id | request_date | accept_date |
|--------------|-------------|--------------|-------------|
| 1            | 2           | 2023-01-01   | 2023-01-02  |
| 1            | 3           | 2023-01-05   | 2023-01-06  |
| 2            | 3           | 2023-01-10   | 2023-01-11  |
| 3            | 4           | 2023-01-15   | 2023-01-16  |

Output:
| id | num_friends |
|----|-------------|
| 3  | 3           |


WITH all_friends AS (
    SELECT requester_id AS id FROM FriendRequest
    UNION ALL
    SELECT accepter_id AS id FROM FriendRequest
),
friend_counts AS (
    SELECT
        id,
        COUNT(*) AS num_friends
    FROM all_friends
    GROUP BY id
)
SELECT
    id,
    num_friends
FROM friend_counts
WHERE num_friends = (
    SELECT MAX(num_friends) FROM friend_counts
);


_________________________________________________________________________
Question: How do data engineers deploy their pipelines into production? [00:06]

Answer: Data pipeline deployment involves two key components: infrastructure and ETL (Extract, Transform, Load) packages. To speed up development, agile practices are used, and the deployment is managed through a CI/CD process using Jenkins.
Infrastructure: Deployed using Terraform code as input. [00:40]
ETL Packages: Packaged based on source code and stored as an artifact in a separate repository. [00:49]

_____________________________________
üîπWrite a SQL query to find the second highest salary in each department. If a department has less than two employees, return NULL for that department.


SELECT
    Department,
    MAX(
        CASE
            WHEN rnk = 2 THEN Salary
        END
    ) AS SecondHighestSalary
FROM (
    SELECT
        Department,
        Salary,
        DENSE_RANK() OVER (
            PARTITION BY Department
            ORDER BY Salary DESC
        ) AS rnk
    FROM Employee
) t
GROUP BY Department;

__________________________________________________________________________________________





______________________________________________________________________________________________
Running total per customer
SELECT
    customer_id,
    order_date,
    SUM(amount) OVER (
        PARTITION BY customer_id
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM orders;

2Ô∏è‚É£ Cumulative average salary per department
SELECT
    dept_id,
    emp_name,
    AVG(salary) OVER (
        PARTITION BY dept_id
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_avg_salary
FROM employees;

3Ô∏è‚É£ 3-row moving average
SELECT
    txn_date,
    amount,
    AVG(amount) OVER (
        ORDER BY txn_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg
FROM transactions;

4Ô∏è‚É£ Running balance (bank account)
SELECT
    account_id,
    txn_time,
    SUM(txn_amount) OVER (
        PARTITION BY account_id
        ORDER BY txn_time
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_balance
FROM account_txns;

5Ô∏è‚É£ Rolling 7-day sales sum
SELECT
    sales_date,
    SUM(daily_sales) OVER (
        ORDER BY sales_date
        RANGE BETWEEN INTERVAL '6' DAY PRECEDING AND CURRENT ROW
    ) AS rolling_7_day_sales
FROM daily_sales;

6Ô∏è‚É£ Cumulative transaction count
SELECT
    user_id,
    txn_time,
    COUNT(*) OVER (
        PARTITION BY user_id
        ORDER BY txn_time
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS txn_count
FROM user_txns;


________________________________________
window function (Dataford)
________

Your team at JPMorgan Chase is preparing to launch a new credit card and needs to estimate how many cards will be issued in its first month.
Your task is to write a SQL query to find out how many cards were issued in the first month of previous card launches. The query should display each credit card's name alongside the quantity issued in its launch month.
Hint: To identify the launch month, refer to the earliest record for each card
monthly_cards_issued table:

Column Name	Description
issue_month	The month the redit card was issued
issue_year	The year the credit card was issued
card_name	The name of the credit card
issued_amount	The number of credit cards issued
Example output:
card_name	issued_amount
Chase Sapphire Reserve	170000
Chase Freedom Flex	65000


with cte as(
select card_name,issued_amount,row_number() over(partition by card_name order by issue_year) as rn1,
row_number() over(partition by card_name,issue_year order by issue_month) as rn2
from monthly_cards_issued 
)
select card_name,issued_amount from cte where rn1=1 and rn2=1

____________________________________________________________________________________________
Write a SQL Query to find the total number of retained customers.

create table users
(
user_id integer,
name varchar(20),
join_date date
);
insert into users
values (1, 'Jon', CAST('2-14-20' AS date)), 
(2, 'Jane', CAST('2-14-20' AS date)), 
(3, 'Jill', CAST('2-15-20' AS date)), 
(4, 'Josh', CAST('2-15-20' AS date)), 
(5, 'Jean', CAST('2-16-20' AS date)), 
(6, 'Justin', CAST('2-17-20' AS date)),
(7, 'Jeremy', CAST('2-18-20' AS date));
create table events
(
user_id integer,
type varchar(10),
access_date date
);
insert into events values
(1, 'Pay', CAST('3-1-20' AS date)), 
(2, 'Music', CAST('3-2-20' AS date)), 
(2, 'P', CAST('3-12-20' AS date)),
(3, 'Music', CAST('3-15-20' AS date)), 
(4, 'Music', CAST('3-15-20' AS date)), 
(1, 'P', CAST('3-16-20' AS date)), 
(3, 'P', CAST('3-22-20' AS date));


WITH music_users AS (
    -- Get users who accessed Music
    SELECT DISTINCT user_id
    FROM events
    WHERE type = 'Music'
),
prime_upgrades AS (
    -- Get users who upgraded to Prime within 30 days of joining
    SELECT DISTINCT u.user_id
    FROM users u
    JOIN events e ON u.user_id = e.user_id
    WHERE e.type = 'P'
    AND e.access_date <= u.join_date + INTERVAL 30 DAY
),
qualified_users AS (
    -- Users who both accessed Music AND upgraded within 30 days
    SELECT m.user_id
    FROM music_users m
    JOIN prime_upgrades p ON m.user_id = p.user_id
)
SELECT 
    COUNT(DISTINCT m.user_id) AS total_users,
    COUNT(DISTINCT q.user_id) AS users_upgraded,
    ROUND(
        total_users / users_upgraded,
        2
    ) AS user_upgraded_fraction
FROM music_users m
LEFT JOIN qualified_users q ON m.user_id = q.user_id;
____________________________________________________________________________________________________________________________________
118)

Write a SQL Query to get the Datewise total number of users who made the purchase same day they installed the app.

CREATE table activity
(
user_id varchar(20),
event_name varchar(20),
event_date date,
country varchar(20)
);

insert into activity values (1,'app-installed','2022-01-01','India')
,(1,'app-purchase','2022-01-02','India')
,(2,'app-installed','2022-01-01','USA')
,(3,'app-installed','2022-01-01','USA')
,(3,'app-purchase','2022-01-03','USA')
,(4,'app-installed','2022-01-03','India')
,(4,'app-purchase','2022-01-03','India')
,(5,'app-installed','2022-01-03','SL')
,(5,'app-purchase','2022-01-03','SL')
,(6,'app-installed','2022-01-04','Pakistan')
,(6,'app-purchase','2022-01-04','Pakistan');



[

WITH installs AS (
    SELECT
        user_id,
        event_date AS install_date
    FROM activity
    WHERE event_name = 'app-installed'
),
purchases AS (
    SELECT
        user_id,
        event_date AS purchase_date
    FROM activity
    WHERE event_name = 'app-purchase'
)
SELECT
    i.install_date,
    COUNT(DISTINCT i.user_id) AS total_users
FROM installs i
JOIN purchases p
    ON i.user_id = p.user_id
   AND i.install_date = p.purchase_date
GROUP BY i.install_date
ORDER BY i.install_date;
]
SELECT i.event_date, count(p.user_id) as total_active_usr
FROM activity i
left JOIN activity p
    ON i.user_id = p.user_id
   and i.event_date=p.event_date
   and i.event_name='app-installed'
   and p.event_name='app-purchase'
   group by i.event_date
   
___________________________________________________________________________________
Write a SQL Query to get the 3 or more consecutive empty seats.


create table bms (seat_no int ,is_empty varchar(10));
insert into bms values
(1,'N')
,(2,'Y')
,(3,'N')
,(4,'Y')
,(5,'Y')
,(6,'Y')
,(7,'N')
,(8,'Y')
,(9,'Y')
,(10,'Y')
,(11,'Y')
,(12,'N')
,(13,'Y')
,(14,'Y');



 with cte as(
  SELECT
    seat_no,
    seat_no - ROW_NUMBER() OVER (ORDER BY seat_no) AS grp
  FROM bms
  WHERE is_empty = 'Y'
  )
  select seat_no from (
  select *,count(*)  over(partition by grp) as cnt from  cte
) temp  where cnt>=3
_____________________________
Write a SQL Query to find students with same marks in physics and chemistry.

create table exams (student_id int, subject varchar(20), marks int);

insert into exams values (1,'Chemistry',91),(1,'Physics',91)
,(2,'Chemistry',80),(2,'Physics',90)
,(3,'Chemistry',80)
,(4,'Chemistry',71),(4,'Physics',54);


with cte as(

select * from exams 
where  subject in ('Physics','Chemistry')
)

select distinct c1.student_id from cte  c1 join cte as c2 on c1.student_id=c2.student_id
and c1.marks=c2.marks
and c1.subject <> c2.subject

# student_id
'1'

________________________________________________________________________________________
Find companies who have atleast 2 users who speaks English and German 
both the languages.

create table company_users 
(
company_id int,
user_id int,
language varchar(20)
);
insert into company_users values (1,1,'English')
,(1,1,'German')
,(1,2,'English')
,(1,3,'German')
,(1,3,'English')
,(1,4,'English')
,(2,5,'English')
,(2,5,'German')
,(2,5,'Spanish')
,(2,6,'German')
,(2,6,'Spanish')
,(2,7,'English');

select user_id,company_id,count(*) as cnt from company_users where language in ('English','German') 
group by company_id,user_id having count(*) >= 2

)
select company_id,count(*)  from cte
group by company_id
having count(*)>=2

_______________________________________________________________________________________________________________________________
100)
Write a SQL Query to find for each seller whether the brand of the second item (by date) they sold is their
 favorite brand. 
 If a seller sold less than two items, report the answer for that seller as No

create table users (
user_id int ,
 join_date date ,
 favorite_brand varchar(50));

 create table orders (
 order_id int ,
 order_date date ,
 item_id int ,
 buyer_id int ,
 seller_id int 
 );
 create table items
 (
 item_id int ,
 item_brand varchar(50)
 );
 insert into users values (1,'2019-01-01','Lenovo'),(2,'2019-02-09','Samsung'),(3,'2019-01-19','LG'),(4,'2019-05-21','HP');

 insert into items values (1,'Samsung'),(2,'Lenovo'),(3,'LG'),(4,'HP');

 insert into orders values (1,'2019-08-01',4,1,2),(2,'2019-08-02',2,1,3),(3,'2019-08-03',3,2,3),(4,'2019-08-04',1,4,2)
 ,(5,'2019-08-04',1,3,4),(6,'2019-08-05',2,2,4);



_____________________________________________________________________________________________________________
Write a SQL Query to find the winner in each group.
The winner in each group is the player who scored the maximum total points within the group. In the case of tie, the lowest player_id wins.


select * from 


create table players
(player_id int,
group_id int)

insert into players values (15,1);
insert into players values (25,1);
insert into players values (30,1);
insert into players values (45,1);
insert into players values (10,2);
insert into players values (35,2);
insert into players values (50,2);
insert into players values (20,3);
insert into players values (40,3);

create table matches
(
match_id int,
first_player int,
second_player int,
first_score int,
second_score int)

insert into matches values (1,15,45,3,0);
insert into matches values (2,30,25,1,2);
insert into matches values (3,30,15,2,0);
insert into matches values (4,40,20,5,2);
insert into matches values (5,35,50,1,1);


with cte as(

select first_player as player,first_score as score from matches union all 
select second_player as player,second_score as score from matches
)
cte2 as(
select sum(score) as total_score,c1.player as player1,c1.group_id  as group_id1 from cte c1 join players p1 on c1.player=p1.player_id group by group_id,c1.player
)
select player1 as player,total_score
from
(
select *,dense_rank() over(partion by group_id1 order by total_score desc, player1 asc) as rnk from cte2
) temp
where rnk=1


_________________________________________________________________________________
Write a SQL Query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned).
Each day between "2013-10-01" and "2013-10-03". Round cancellation rate to two dedimal points.
The cancellation rate is computed by dividing the number of cancelled (by client or driver) requests with unbanned users by the total
number of requests with unbanned users on that day.


Create table Trips (id int, client_id int, driver_id int, city_id int, status varchar(50), request_at varchar(50));

Create table Users (users_id int, banned varchar(50), role varchar(50));


SELECT 
    request_at,
    ROUND(
        SUM(CASE WHEN status <> 'Completed' THEN 1 ELSE 0 END) / COUNT(*),
        2
    ) AS cancellation_rate
FROM Trips t
JOIN Users u1 ON t.client_id = u1.users_id AND u1.banned = 'No'
JOIN Users u2 ON t.driver_id = u2.users_id AND u2.banned = 'No'
WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03'
GROUP BY request_at;

____________________________________________________________________________






_________________________________________________________________________________________________________________________________
Write a sql query to find PersonID, Name, Number of friends, sum of marks of person who have friends with total score greater than 100.

CREATE TABLE person 
 (
 PersonID INT,
 Name STRING,
 Email STRING,
 Score INT
 );
INSERT INTO person 
VALUES (1, 'Alice', 'alice2018@hotmail.com', 88),
(2, 'Bob', 'bob2018@hotmail.com', 11),
(3, 'Davis', 'davis2018@hotmail.com', 27),
(4, 'Tara', 'tara2018@hotmail.com', 45),
(5, 'John', 'john2018@hotmail.com', 63);

CREATE TABLE friend 
(PersonID INT, FriendID INT);

INSERT INTO friend 
VALUES (1,2), (1,3), (2,1), (2,3), 
(3,5), (4,2), (4,3), (4,5);

SELECT
    f.PersonID,
    COUNT(f.FriendID) AS NumberOfFriends,
    SUM(p.Score) AS TotalFriendScore
FROM friend f
JOIN person p
    ON f.FriendID = p.PersonID
GROUP BY f.PersonID
HAVING SUM(p.Score) > 100;

or
with cte as(
select f.PersonID,count(*) as tf,sum(score) as total_f_s from person p1 join friend f on p1.PersonID=f.FriendID group by f.PersonID
)
select ct.PersonID,name,tf,total_f_s from cte ct join person p on ct.PersonID=p.PersonID where total_f_s>100
_____________________________________________________________________________________
Write a SQL query to find all couples of trade for some stock that happened in the range of 10 seconds
and having price difference by more than 10%.
Output result should also list the percentage of price difference between the 2 trade

Create Table Trade_tbl(
TRADE_ID varchar(20),
Trade_Timestamp time,
Trade_Stock varchar(20),
Quantity int,
Price Float
)

Insert into Trade_tbl Values('TRADE1','10:01:05','ITJunction4All',100,20)
Insert into Trade_tbl Values('TRADE2','10:01:06','ITJunction4All',20,15)
Insert into Trade_tbl Values('TRADE3','10:01:08','ITJunction4All',150,30)
Insert into Trade_tbl Values('TRADE4','10:01:09','ITJunction4All',300,32)
Insert into Trade_tbl Values('TRADE5','10:10:00','ITJunction4All',-100,19)
Insert into Trade_tbl Values('TRADE6','10:10:01','ITJunction4All',-300,19)


select t1.TRADE_ID as first_trade, t2.TRADE_ID as second_trade, t1.price as first_trade_price,t2.price as second_price,
ROUND(100*(abs(t1.price-t2.price))/t1.price,2) 
from Trade_tbl t1 join  Trade_tbl t2  on t1.TRADE_ID< t2.TRADE_ID
where 
abs(TIMESTAMPDIFF(second,t1.Trade_Timestamp,t2.Trade_Timestamp)) <=10
and
100*(abs(t1.price-t2.price))/t1.price >10 
order by t1.TRADE_ID

	first_trade	second_trade	first_trade_price	second_price	percent_diff
	TRADE1	TRADE2	20.00	15.00	25.00
	TRADE1	TRADE3	20.00	30.00	50.00
	TRADE1	TRADE4	20.00	32.00	60.00
	TRADE2	TRADE3	15.00	30.00	100.00
	TRADE2	TRADE4	15.00	32.00	113.33



_______________________________________________________________________________________________________
we have a table which stores data of multiple sections. every section has 3 numbers
we have to find top 4 numbers from any 2 sections(2 numbers each) whose addition should be maximum
so in this case we will choose section b where we have 19(10+9) then we need to choose either C or D
because both has sum of 18 but in D we have 10 which is bigger than 9 so we will give priority to D.




create table section_data
(
section varchar(5),
number integer
)
insert into section_data
values ('A',5),('A',7),('A',10) ,('B',7),('B',9),('B',10) ,('C',9),('C',7),('C',9) ,('D',10),('D',3),('D',8);



with top2 as(
select *,ROW_NUMBER() over(partition by section order by number desc) as row_num from section_data
),
pick2 as(
select section,number from top2 where row_num<=2
),
cte as(
select section,sum(number) as sum2,max(number) as max_number from pick2  group by section
),
cte2 as(
select section,sum2,max_number from cte order by sum2 desc,max_number desc limit 2
)

select s.section,s.number from pick2 s join cte2 t2 on s.section=t2.section order by s.section desc,s.number desc 

__________________________________________________________________________________________
Write a SQL query to find the total number of matches played, number of winning teams, and number of losses.
create table icc_world_cup
(
Team_1 Varchar(20),
Team_2 Varchar(20),
Winner Varchar(20)
);
INSERT INTO icc_world_cup values('India','SL','India');
INSERT INTO icc_world_cup values('SL','Aus','Aus');
INSERT INTO icc_world_cup values('SA','Eng','Eng');
INSERT INTO icc_world_cup values('Eng','NZ','NZ');
INSERT INTO icc_world_cup values('Aus','India','India');



with  cte as(
select Team_1 as team, case when Team_1=Winner then 1 else 0 end as winner_flag from icc_world_cup
union all
select Team_2 as team, case when Team_2=Winner then 1 else 0 end as winner_flag from icc_world_cup
),
cte2 as(
select team,count(team) as total_match_played, sum(winner_flag) as win from cte group by team
)
select *,(total_match_played - win) as losses from cte2


India	2	2	0
SL	2	0	2
SA	1	0	1
Eng	2	1	1
Aus	2	1	1
NZ	1	1	0

__________________________________________________________________



Imagine you're working for a library and you're tasked with generating a report on the borrowing habits of patrons. You have two tables in your database: Books and Borrowers.

 

Write an SQL to display the name of each borrower along with a comma-separated list of the books they have borrowed in alphabetical order, display the output in ascending order of Borrower Name.

 

Tables: Books
+-------------+-------------+
| COLUMN_NAME | DATA_TYPE   |
+-------------+-------------+
| BookID      | int         |
| BookName    | varchar(30) |
| Genre       | varchar(20) |
+-------------+-------------+

Tables: Borrowers
+--------------+-------------+
| COLUMN_NAME  | DATA_TYPE   |
+--------------+-------------+
| BorrowerID   | int         |
| BorrowerName | varchar(10) |
| BookID       | int         |
+--------------+-------------+


select BorrowerName,GROUP_CONCAT(b.BookName order by b.BookName SEPARATOR ', ') from Borrowers br inner join 
Books b on br.BookID=b.BookID
GROUP BY br.BorrowerName
order by BorrowerName

________________________________
Write a SQL query to find the total number of new and repeated customers.

create table customer_orders (
order_id integer,
customer_id integer,
order_date date,
order_amount integer
);
insert into customer_orders values(1,100,cast('2022-01-01' as date),2000),(2,200,cast('2022-01-01' as date),2500),(3,300,cast('2022-01-01' as date),2100)
,(4,100,cast('2022-01-02' as date),2000),(5,400,cast('2022-01-02' as date),2200),(6,500,cast('2022-01-02' as date),2700)
,(7,100,cast('2022-01-03' as date),3000),(8,400,cast('2022-01-03' as date),1000),(9,600,cast('2022-01-03' as date),3000);


with cte as(

select *, row_number() over(partition by customer_id order by order_amount desc) as rn from customer_orders  

)
select order_date,sum(case when rn >1 then 1 else 0 end) as old_cust,sum(case when rn =1 then 1 else 0 end) as new_cust, from cte group by order_date 

2022-01-01	0	3
2022-01-02	1	2
2022-01-03	2	1
__________________________________________________________________________________

Write a SQL query to find the total_visits, most_visited_floor, and resources_used

create table entries ( 
name varchar(20),
address varchar(20),
email varchar(20),
floor int,
resources varchar(10));

insert into entries 
values ('A','Bangalore','A@gmail.com',1,'CPU'),('A','Bangalore','A1@gmail.com',1,'CPU'),('A','Bangalore','A2@gmail.com',2,'DESKTOP')
,('B','Bangalore','B@gmail.com',2,'DESKTOP'),('B','Bangalore','B1@gmail.com',2,'DESKTOP'),('B','Bangalore','B2@gmail.com',1,'MONITOR')





with cte as(
select name,count(*) as total_f_c from entries group by name
),
floor_visit_count as (

select *,row_number() over(partition by  name order by total_count desc) as rnk   from (
select name,floor,count(*) as total_count from
entries group by name , floor
)  temp2
),
resources1 AS (
select name,GROUP_CONCAT(resources,',') as resources_used from
(
select distinct name,resources from entries
) temp
group by name
)
select c.name,total_f_c,floor,resources_used from cte c join floor_visit_count f on c.name=f.name 
join resources1 r1 on c.name=r1.name
 where rnk=1


________________________________________________________________________________________________







