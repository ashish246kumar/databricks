_____________________________________________________________________________________
Write a SQL query to find all couples of trade for some stock that happened in the range of 10 seconds
and having price difference by more than 10%.
Output result should also list the percentage of price difference between the 2 trade

Create Table Trade_tbl(
TRADE_ID varchar(20),
Trade_Timestamp time,
Trade_Stock varchar(20),
Quantity int,
Price Float
)

Insert into Trade_tbl Values('TRADE1','10:01:05','ITJunction4All',100,20)
Insert into Trade_tbl Values('TRADE2','10:01:06','ITJunction4All',20,15)
Insert into Trade_tbl Values('TRADE3','10:01:08','ITJunction4All',150,30)
Insert into Trade_tbl Values('TRADE4','10:01:09','ITJunction4All',300,32)
Insert into Trade_tbl Values('TRADE5','10:10:00','ITJunction4All',-100,19)
Insert into Trade_tbl Values('TRADE6','10:10:01','ITJunction4All',-300,19)


select t1.TRADE_ID as first_trade, t2.TRADE_ID as second_trade, t1.price as first_trade_price,t2.price as second_price,
ROUND(100*(abs(t1.price-t2.price))/t1.price,2) 
from Trade_tbl t1 join  Trade_tbl t2  on t1.TRADE_ID< t2.TRADE_ID
where 
abs(TIMESTAMPDIFF(second,t1.Trade_Timestamp,t2.Trade_Timestamp)) <=10
and
100*(abs(t1.price-t2.price))/t1.price >10 
order by t1.TRADE_ID

	first_trade	second_trade	first_trade_price	second_price	percent_diff
	TRADE1	TRADE2	20.00	15.00	25.00
	TRADE1	TRADE3	20.00	30.00	50.00
	TRADE1	TRADE4	20.00	32.00	60.00
	TRADE2	TRADE3	15.00	30.00	100.00
	TRADE2	TRADE4	15.00	32.00	113.33



_______________________________________________________________________________________________________
we have a table which stores data of multiple sections. every section has 3 numbers
we have to find top 4 numbers from any 2 sections(2 numbers each) whose addition should be maximum
so in this case we will choose section b where we have 19(10+9) then we need to choose either C or D
because both has sum of 18 but in D we have 10 which is bigger than 9 so we will give priority to D.




create table section_data
(
section varchar(5),
number integer
)
insert into section_data
values ('A',5),('A',7),('A',10) ,('B',7),('B',9),('B',10) ,('C',9),('C',7),('C',9) ,('D',10),('D',3),('D',8);



with top2 as(
select *,ROW_NUMBER() over(partition by section order by number desc) as row_num from section_data
),
pick2 as(
select section,number from top2 where row_num<=2
),
cte as(
select section,sum(number) as sum2,max(number) as max_number from pick2  group by section
),
cte2 as(
select section,sum2,max_number from cte order by sum2 desc,max_number desc limit 2
)

select s.section,s.number from pick2 s join cte2 t2 on s.section=t2.section order by s.section desc,s.number desc 

__________________________________________________________________________________________
Write a SQL query to find the total number of matches played, number of winning teams, and number of losses.
create table icc_world_cup
(
Team_1 Varchar(20),
Team_2 Varchar(20),
Winner Varchar(20)
);
INSERT INTO icc_world_cup values('India','SL','India');
INSERT INTO icc_world_cup values('SL','Aus','Aus');
INSERT INTO icc_world_cup values('SA','Eng','Eng');
INSERT INTO icc_world_cup values('Eng','NZ','NZ');
INSERT INTO icc_world_cup values('Aus','India','India');



with  cte as(
select Team_1 as team, case when Team_1=Winner then 1 else 0 end as winner_flag from icc_world_cup
union all
select Team_2 as team, case when Team_2=Winner then 1 else 0 end as winner_flag from icc_world_cup
),
cte2 as(
select team,count(team) as total_match_played, sum(winner_flag) as win from cte group by team
)
select *,(total_match_played - win) as losses from cte2


India	2	2	0
SL	2	0	2
SA	1	0	1
Eng	2	1	1
Aus	2	1	1
NZ	1	1	0

__________________________________________________________________



Imagine you're working for a library and you're tasked with generating a report on the borrowing habits of patrons. You have two tables in your database: Books and Borrowers.

 

Write an SQL to display the name of each borrower along with a comma-separated list of the books they have borrowed in alphabetical order, display the output in ascending order of Borrower Name.

 

Tables: Books
+-------------+-------------+
| COLUMN_NAME | DATA_TYPE   |
+-------------+-------------+
| BookID      | int         |
| BookName    | varchar(30) |
| Genre       | varchar(20) |
+-------------+-------------+

Tables: Borrowers
+--------------+-------------+
| COLUMN_NAME  | DATA_TYPE   |
+--------------+-------------+
| BorrowerID   | int         |
| BorrowerName | varchar(10) |
| BookID       | int         |
+--------------+-------------+


select BorrowerName,GROUP_CONCAT(b.BookName order by b.BookName SEPARATOR ', ') from Borrowers br inner join 
Books b on br.BookID=b.BookID
GROUP BY br.BorrowerName
order by BorrowerName

________________________________
Write a SQL query to find the total number of new and repeated customers.

create table customer_orders (
order_id integer,
customer_id integer,
order_date date,
order_amount integer
);
insert into customer_orders values(1,100,cast('2022-01-01' as date),2000),(2,200,cast('2022-01-01' as date),2500),(3,300,cast('2022-01-01' as date),2100)
,(4,100,cast('2022-01-02' as date),2000),(5,400,cast('2022-01-02' as date),2200),(6,500,cast('2022-01-02' as date),2700)
,(7,100,cast('2022-01-03' as date),3000),(8,400,cast('2022-01-03' as date),1000),(9,600,cast('2022-01-03' as date),3000);


with cte as(

select *, row_number() over(partition by customer_id order by order_amount desc) as rn from customer_orders  

)
select order_date,sum(case when rn >1 then 1 else 0 end) as old_cust,sum(case when rn =1 then 1 else 0 end) as new_cust, from cte group by order_date 

2022-01-01	0	3
2022-01-02	1	2
2022-01-03	2	1
__________________________________________________________________________________

Write a SQL query to find the total_visits, most_visited_floor, and resources_used

create table entries ( 
name varchar(20),
address varchar(20),
email varchar(20),
floor int,
resources varchar(10));

insert into entries 
values ('A','Bangalore','A@gmail.com',1,'CPU'),('A','Bangalore','A1@gmail.com',1,'CPU'),('A','Bangalore','A2@gmail.com',2,'DESKTOP')
,('B','Bangalore','B@gmail.com',2,'DESKTOP'),('B','Bangalore','B1@gmail.com',2,'DESKTOP'),('B','Bangalore','B2@gmail.com',1,'MONITOR')





with cte as(
select name,count(*) as total_f_c from entries group by name
),
floor_visit_count as (

select *,row_number() over(partition by  name order by total_count desc) as rnk   from (
select name,floor,count(*) as total_count from
entries group by name , floor
)  temp2
),
resources1 AS (
select name,GROUP_CONCAT(resources,',') as resources_used from
(
select distinct name,resources from entries
) temp
group by name
)
select c.name,total_f_c,floor,resources_used from cte c join floor_visit_count f on c.name=f.name 
join resources1 r1 on c.name=r1.name
 where rnk=1


________________________________________________________________________________________________







